import type { FilterQuery } from 'mongoose'

import { EmoteModel } from '../models/emote.model'
import type { EmoteDocument } from '../models/emote.model'
import type { EmoteNoUContextQueryOptions, EmoteNouChainQueryOptions, EmoteQueryOptions, EmoteRequest, EmoteResponse } from '../types/emote.types'
import { InternalServerError } from './errors'
import { mapEmoteResponse, mapEmoteResponseWithNoUChainPreviews } from '../util/emoteUtil'
import escapeStringRegexp from 'escape-string-regexp'
import { createSymbolInDB, fetchAllSymbolsFromDB } from './symbol.service'
import { createEmoteNotifInDB } from './emote-notif.service'
import { getFrontendURL } from '../util/seoConstantsUtil'

export async function createEmoteInDB(emoteData: Partial<EmoteRequest>): Promise<EmoteResponse | null> {
  if (!emoteData.sentSymbols || emoteData.sentSymbols.length === 0) {
    console.error('No sentSymbols provided')
    throw new InternalServerError('No sentSymbols provided')
  }

  for (const sentSymbol of emoteData.sentSymbols) {
    // Check if sentSymbol exists
    const symbols = await fetchAllSymbolsFromDB({ search: sentSymbol } as any)
    if (symbols?.length === 0) {
      // Create the sentSymbol if it does not exist
      await createSymbolInDB({ name: sentSymbol.toLowerCase() })
    }
  }

  try {
    const emoteBuildData = {
      senderTwitterUsername: emoteData.senderTwitterUsername as string,
      receiverSymbols: emoteData.receiverSymbols as string[],
      sentSymbols: emoteData?.sentSymbols as string[],
      ...(emoteData?.timestamp ? { createdAt: emoteData.timestamp } : {}),  // this is for when creating multiple emotes at once - you set all their timestamp to exact same datetime - otherwise they will be slightly different if generated by mongoose
    }
    const emoteDoc = EmoteModel.build(emoteBuildData)
    const createdEmote = await EmoteModel.create(emoteDoc)

    // if one of receiverSymbol is X user, then do notification stuff. Otherwise, no need (although will be need for autonomous agents at some point probably)
    // const pattern = /^@?(\w){1,15}$/
    // const isPossibleXUser = pattern.test(emoteData.receiverSymbol as string)
    // if (isPossibleXUser) {
    //   await createEmoteNotifInDB({ emoteID: createdEmote._id.toString() })
    // }

    const pattern = /^@?(\w){1,15}$/
    emoteData.receiverSymbols?.forEach(async (receiverSymbol) => {
      const isPossibleXUser = pattern.test(receiverSymbol)
      if (isPossibleXUser) {
        await createEmoteNotifInDB({ emoteID: createdEmote._id.toString(), receiverSymbol })
      }
    })

    return mapEmoteResponse(createdEmote)
  } catch (error) {
    console.error('Error occurred while creating emote in DB', error)
    throw new InternalServerError('Failed to create emote in DB')
  }

}

export async function fetchEmoteFromDB(EmoteId: string): Promise<EmoteResponse | null> {
  try {
    const emoteDoc = await EmoteModel.findById(EmoteId)
    return emoteDoc ? mapEmoteResponse(emoteDoc.toObject()) as EmoteResponse : null
  } catch (error) {
    console.error('Error occurred while fetching Emote from DB', error)
    throw new InternalServerError('Failed to fetch Emote from DB')
  }
}

export async function fetchAllEmotesFromDB(
  options: EmoteQueryOptions
): Promise<EmoteResponse[]> {
  try {

    const { skip, limit, orderBy, senderTwitterUsername, receiverSymbols, sentSymbols } = options
    const orderDirection = options.orderDirection === 'asc' ? 1 : -1

    // Sorting Options
    const sortOptions: any = {}
    sortOptions[orderBy] = orderDirection
    sortOptions._id = 1

    // Filter Options
    const filterOptions: FilterQuery<EmoteDocument>[] = []

    if (senderTwitterUsername) {
      filterOptions.push({
        $or: [
          { senderTwitterUsername: { $regex: new RegExp("^" + senderTwitterUsername + "$", 'iu') } },
        ],
      })
    }

    // TODO: test the crap out dis - it confuse me
    // decision: if multiple symbols in receiverSymbols, then each returned Emote must have receiverSymbols field that contains all requested. So what i mean is that it wont return Emotes with just the first receiverSymbol - it has to be ALL in the list. BUT, it also accepts extras in sentSymbols too AS LONG as it has ALL requested sentSymbols.
    if (receiverSymbols && receiverSymbols?.length > 0) {
      // filterOptions.push({
      //   $or: [
      //     { receiverSymbol: { $regex: new RegExp("^" + receiverSymbol + "$", 'iu') } },
      //   ],
      // })
      const regexOrConditions = receiverSymbols.map(symbol => ({
        receiverSymbols: { $regex: new RegExp("^" + escapeStringRegexp(symbol) + "$", 'iu') }
      }));
      filterOptions.push({
        $and: regexOrConditions,  // the AND is what enforces the decision above. OR will be different functionality
      })
    }


    // TODO: test the crap out dis - it confuse me
    // decision: if multiple symbols in sentSymbols, then each returned Emote must have sentSymbols field that contains all requested. So what i mean is that it wont return Emotes with just the first receiverSymbol - it has to be ALL in the list. BUT, it also accepts extras in sentSymbols too AS LONG as it has ALL requested sentSymbols.
    if (sentSymbols && sentSymbols?.length > 0) {
      const regexOrConditions = sentSymbols.map(sentSymbol => ({
        sentSymbols: { $regex: new RegExp("^" + escapeStringRegexp(sentSymbol) + "$", 'iu') }
      }));
      filterOptions.push({
        $and: regexOrConditions,  // the AND is what enforces the decision above. OR will be different functionality
      })
    }

    // Filter Query
    let filterQuery = {}
    if (filterOptions.length > 0) {
      filterQuery = { $and: filterOptions }
    }

    const emoteDocs: EmoteDocument[] = await EmoteModel
      .find(filterQuery)
      .sort(sortOptions)
      .skip(skip)
      .limit(limit)

    return emoteDocs.map((doc) => mapEmoteResponse(doc) as EmoteResponse)
  } catch (error) {
    console.error('Error occurred while fetching all emotes from DB', error)
    throw new InternalServerError('Failed to fetch all emotes from DB')
  }
}

// get unresponded received emotes in the no u context (these conditions based on emotes sent at same timestamp as main emote)
export async function fetchUnrespondedEmotesFromDB(
  receiverOrSenderSymbol: string,
  options: EmoteNoUContextQueryOptions
): Promise<EmoteResponse[]> {
  const { skip, limit, orderBy, orderDirection, fetchSentOrReceived } = options

  const primaryUserFilter = fetchSentOrReceived === 'sent'
    ?
    {
      $match: {
        senderTwitterUsername: receiverOrSenderSymbol,
        receiverSymbols: {
          // this is what filters out the additional emotes used for identifying noucontext and replies - prob not ideal tbh 
          $not: {
            $in: [
              new RegExp(escapeStringRegexp("nou context"), 'iu'),
              new RegExp(escapeStringRegexp(`${getFrontendURL()}/emote/`), 'iu')
            ]
          }
        },
      } 
    }
    // luckily this condition filters out the additional emotes used for identifying noucontext and replies. When fetchSentOrReceived === 'sent' - not so lucky
    : { $match: { receiverSymbols: receiverOrSenderSymbol } }

  try {
    const pipeline = [
      // Match emotes received by the user
      primaryUserFilter,
      // Lookup to join with the same collection to find "no u" context emotes
      {
        $lookup: {
          from: 'emotes', // Assuming the collection name is 'emotes'
          let: { emoteCreatedAt: "$createdAt", emoteId: "$_id" },
          pipeline: [
            {
              // this finds the emote that identifies if primary emote (being looped one at a time) is no u context emote. If not, i guess it filters this primary emote out?
              // more simply, i think this just filters out all non-noucontext emotes from results
              $match: {
                $expr: {
                  $and: [
                    { $eq: ["$createdAt", "$$emoteCreatedAt"] },
                    { $in: ["symbol", "$sentSymbols"] },
                    { $in: ["nou context", "$receiverSymbols"] }
                  ]
                }
              }
            },
            // Check if the emote has been replied to
            {
              $lookup: {
                from: 'emotes',
                let: { emoteId: "$$emoteId" },
                pipeline: [
                  {
                    $match: {
                      $expr: {
                        $and: [
                          // TODO: i think one day could add in sender of user too as extra filter
                          { $in: ["reply", "$sentSymbols"] },
                          { $in: [{ $concat: [`${getFrontendURL()}/emote/`, { $toString: "$$emoteId" }] }, "$receiverSymbols"] }
                        ]
                      }
                    }
                  },
                ],
                as: 'replies'
              }
            },
            {
              $match: {
                // Ensure no replies exist
                $expr: { $eq: [{ $size: "$replies" }, 0] }
              }
            },
          ],
          as: 'noUContextEmotes'
        }
      },
      // Filter out documents that didn't join with "no u" context emotes
      { $match: { "noUContextEmotes.0": { $exists: true } } },
      // Apply skip and limit
      { $skip: skip },
      { $limit: limit },
      { $sort: { [orderBy]: orderDirection === 'asc' ? 1 : -1 } } as any
    ]

    const result = await EmoteModel.aggregate(pipeline)

    const emotesWithReplyChains = await Promise.all(result.map(async (emote) => {
      const orderBy = 'timestamp'
      const orderDirection = 'desc'
      // skip 1 bc otherwise the preview will start with the emote passed in (which is one displayed on frontend so dont need duplicate of it)
      const { chain, totalChainLength } = await findEmoteReplyChainInDB(emote._id, { skip: 1, limit: 2, orderBy, orderDirection }) // Adjust skip and limit as needed
      return { ...emote, chainPreview: chain, totalChainLength }
    }))

    // Assuming you need to map the results to your EmoteResponse format
    return emotesWithReplyChains.map(mapEmoteResponseWithNoUChainPreviews) as EmoteResponse[]
  } catch (error) {
    console.error('Error occurred while fetching unresponded emotes using aggregation', error)
    throw new InternalServerError('Failed to fetch unresponded emotes')
  }
}

// take in emote and if it is a reply, keep iterating backwards to find all prior replies
// a reply is identified by a separate emote DB record with same createdAt as emote replied to
export async function findEmoteReplyChainInDB(emoteId: string, options: EmoteNouChainQueryOptions): Promise<{ chain: EmoteResponse[], totalChainLength: number }> {
  let currentEmote = await EmoteModel.findById(emoteId) as any
  if (!currentEmote) {
    throw new Error('Emote not found')
  }

  const { skip, limit, orderBy, orderDirection, } = options

  const chain: any[] = [mapEmoteResponse(currentEmote.toObject())] as any
  let searching = true
  let totalChainLength = 1 // Initialize total length with the first emote

  while (searching) {
    const createdAt = currentEmote.createdAt

    // Find the emote that indicates a reply, by matching createdAt and containing a URL in receiverSymbols
    const replyIndicatorEmote = await EmoteModel.findOne({
      createdAt: createdAt,
      sentSymbols: 'reply'
    })

    if (!replyIndicatorEmote) {
      searching = false // No reply indicator found, end of chain
      break
    }

    // Extract the replied-to emote ID from the reply indicator
    const repliedToUrl = replyIndicatorEmote.receiverSymbols.find(symbol => symbol.startsWith(`${getFrontendURL()}/emote/`));
    const repliedToEmoteId = repliedToUrl?.split('/').pop()

    if (!repliedToEmoteId) {
      searching = false // Malformed URL or end of chain
      break
    }

    // Find the emote that was replied to
    const repliedToEmote = await EmoteModel.findById(repliedToEmoteId)

    if (repliedToEmote) {
      chain.unshift(mapEmoteResponse(repliedToEmote.toObject())) // Prepend to maintain order
      currentEmote = repliedToEmote // Set this as the current emote for the next iteration
      totalChainLength++ // Increment total length
    } else {
      searching = false // No further replies found
    }
  }

  // Sort the chain based on orderBy and orderDirection
  // this defs works for timestamp (and i think any numerical values), but otherwise wont work
  chain.sort((a, b) => {
    if (options.orderDirection === 'asc') {
        return a[options.orderBy] > b[options.orderBy] ? 1 : -1;
    } else {
        return a[options.orderBy] < b[options.orderBy] ? 1 : -1;
    }
  })

  // Apply skip and limit
  const paginatedChain = chain.slice(skip, skip + limit)

  return { chain: paginatedChain, totalChainLength }
}

// export async function updateEmoteInDB(EmoteId: string, updatedData: Partial<EmoteResponse>): Promise<EmoteResponse | null> {
//   try {
//     const updatedEmoteDoc = await EmoteModel.findByIdAndUpdate(EmoteId, updatedData, { new: true })
//     return updatedEmoteDoc ? updatedEmoteDoc.toObject() : null
//   } catch (error) {
//     console.error('Error occurred while updating Emote in DB', error)
//     throw new InternalServerError('Failed to update Emote in DB')
//   }
// }

export async function deleteEmoteInDB(emoteId: string): Promise<void> {
  try {
    await EmoteModel.findByIdAndDelete(emoteId)
  } catch (error) {
    console.error('Error occurred while deleting emote from DB', error)
    throw new InternalServerError('Failed to delete emote from DB')
  }
}
